В данном материале будут рассмотрены примеры использования связки Apache Camel и ScalaDSL для реализации заглушек информационных систем при тестировании.
Часто возникает необходимость сэмулировать работу какой-либо системы для интеграционного тестирования, сделать заглушку или написать простой компонент интеграции.
Цель - краткое описание с примерами для быстрой реализации заглушек систем.
Apache camel ( http://camel.apache.org/ )- java фреймворк, предназначенный для реализации обмена сообщениями между компонентами информационной системы. Реализует т.н. EIP - Enterprise Integration Patterns.
Существует возможность работы с файлами, БД, менеджерами очередей, веб-сервисами, и другими компонентами - их около 240 на странице проекта http://camel.apache.org/component.html
Компонент может реализовывать как поставщика сообщения(Producer), так и получателя(Consumer).

Общий смысл таков:
1) Описываем источник сообщения(файл, очередь, БД, сервис, таймер и т.п.);
2) Описываем правила преобразования данных и форматов;
3) Описываем получателя (получателей) сообщения(файл, очередь, БД, сервис, вывод в консоль и т.п.) и логику маршрутизации;
4) Запускаем приложение, которое слушает источник, и при появлении сообщения преобразует его и маршрутизирует до получателей.
Рассмотрим подробнее на примерах.

Для описания правил маршрутизации и преобразования сообщений используются различные языки( http://camel.apache.org/languages.html ). Мы будем использовать Scala DSL, систему сборки проекта sbt.

Будет рассмотрено 4 сценария, с возраствнием сложности:
1) Чтение файлов в одной кодировке, запись в другой;
2) Запрос к веб сервису по-расписанию и сохранение сообщения в Redis;
3) Реализация веб-сервиса с использованием jetty, который возвращает сообщение в зависимости от параметра get запроса;
3) Чтение сообщения из файла и отправка сообщения в БД или в очередь, в зависимости от условий.

Также существует отличный пример с чтением сообщения из файла и отправкой его http post запросом. Пример немного устаревший, но может быть полезен.
http://www.lightbend.com/activator/template/camel-http
https://github.com/hilton/activator-camel-http#master

Подготовительные работы
Создадим проект в idea, пример - ???
В файле build.sbt пропишем настройки

name := "camel-scaladsl"

version := "1.0"

scalaVersion := "2.11.8"

val camelVersion = "2.17.1"

libraryDependencies ++= Seq(
  // Компоненты для Camel
  "org.apache.camel" % "camel-core" % camelVersion,
  "org.apache.camel" % "camel-scala" % camelVersion,
  //Добавим логгирование
  "ch.qos.logback" % "logback-classic" % "1.1.2",
  "org.slf4j" % "slf4j-api" % "1.7.7",
  //Компонент для работы xml в скала
  "org.scala-lang.modules" % "scala-xml_2.11" % "1.0.5"
)

Добавим в папку src/main/resources файл logback.xml, в котором можем установить уровень логгирования и формат сообщения.

<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <root level="INFO">
        <appender-ref ref="STDOUT" />
    </root>
</configuration>

Без этого файла по-умолчанию работает уровень DEBUG - сыпется слишком много информации.
Опционально, возможно добавление компонента для конфигурации приложения,  https://github.com/typesafehub/config, чтобы не зашивать параметры подключения в коде, а хранить в json файле
в build.sbt добавляем
libraryDependencies += "com.typesafe" % "config" % "1.3.0"
в папке src/main/resources создаем файл application.conf
Более подробно останавливаться не будем.





